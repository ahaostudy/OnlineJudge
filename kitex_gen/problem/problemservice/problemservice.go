// Code generated by Kitex v0.7.2. DO NOT EDIT.

package problemservice

import (
	"context"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
	problem "main/kitex_gen/problem"
)

func serviceInfo() *kitex.ServiceInfo {
	return problemServiceServiceInfo
}

var problemServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ProblemService"
	handlerType := (*problem.ProblemService)(nil)
	methods := map[string]kitex.MethodInfo{
		"GetProblem":            kitex.NewMethodInfo(getProblemHandler, newGetProblemArgs, newGetProblemResult, false),
		"GetProblemList":        kitex.NewMethodInfo(getProblemListHandler, newGetProblemListArgs, newGetProblemListResult, false),
		"GetProblemCount":       kitex.NewMethodInfo(getProblemCountHandler, newGetProblemCountArgs, newGetProblemCountResult, false),
		"GetContestProblem":     kitex.NewMethodInfo(getContestProblemHandler, newGetContestProblemArgs, newGetContestProblemResult, false),
		"GetContestProblemList": kitex.NewMethodInfo(getContestProblemListHandler, newGetContestProblemListArgs, newGetContestProblemListResult, false),
		"CreateProblem":         kitex.NewMethodInfo(createProblemHandler, newCreateProblemArgs, newCreateProblemResult, false),
		"DeleteProblem":         kitex.NewMethodInfo(deleteProblemHandler, newDeleteProblemArgs, newDeleteProblemResult, false),
		"UpdateProblem":         kitex.NewMethodInfo(updateProblemHandler, newUpdateProblemArgs, newUpdateProblemResult, false),
		"CreateTestcase":        kitex.NewMethodInfo(createTestcaseHandler, newCreateTestcaseArgs, newCreateTestcaseResult, false),
		"GetTestcase":           kitex.NewMethodInfo(getTestcaseHandler, newGetTestcaseArgs, newGetTestcaseResult, false),
		"DeleteTestcase":        kitex.NewMethodInfo(deleteTestcaseHandler, newDeleteTestcaseArgs, newDeleteTestcaseResult, false),
	}
	extra := map[string]interface{}{
		"PackageName":     "problem",
		"ServiceFilePath": ``,
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.7.2",
		Extra:           extra,
	}
	return svcInfo
}

func getProblemHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetProblemRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetProblem(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetProblemArgs:
		success, err := handler.(problem.ProblemService).GetProblem(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetProblemResult)
		realResult.Success = success
	}
	return nil
}
func newGetProblemArgs() interface{} {
	return &GetProblemArgs{}
}

func newGetProblemResult() interface{} {
	return &GetProblemResult{}
}

type GetProblemArgs struct {
	Req *problem.GetProblemRequest
}

func (p *GetProblemArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetProblemRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetProblemArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetProblemArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetProblemArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetProblemArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetProblemArgs_Req_DEFAULT *problem.GetProblemRequest

func (p *GetProblemArgs) GetReq() *problem.GetProblemRequest {
	if !p.IsSetReq() {
		return GetProblemArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetProblemArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetProblemArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetProblemResult struct {
	Success *problem.GetProblemResponse
}

var GetProblemResult_Success_DEFAULT *problem.GetProblemResponse

func (p *GetProblemResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetProblemResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetProblemResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetProblemResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetProblemResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetProblemResult) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetProblemResult) GetSuccess() *problem.GetProblemResponse {
	if !p.IsSetSuccess() {
		return GetProblemResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetProblemResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetProblemResponse)
}

func (p *GetProblemResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetProblemResult) GetResult() interface{} {
	return p.Success
}

func getProblemListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetProblemListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetProblemList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetProblemListArgs:
		success, err := handler.(problem.ProblemService).GetProblemList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetProblemListResult)
		realResult.Success = success
	}
	return nil
}
func newGetProblemListArgs() interface{} {
	return &GetProblemListArgs{}
}

func newGetProblemListResult() interface{} {
	return &GetProblemListResult{}
}

type GetProblemListArgs struct {
	Req *problem.GetProblemListRequest
}

func (p *GetProblemListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetProblemListRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetProblemListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetProblemListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetProblemListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetProblemListArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetProblemListArgs_Req_DEFAULT *problem.GetProblemListRequest

func (p *GetProblemListArgs) GetReq() *problem.GetProblemListRequest {
	if !p.IsSetReq() {
		return GetProblemListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetProblemListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetProblemListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetProblemListResult struct {
	Success *problem.GetProblemListResponse
}

var GetProblemListResult_Success_DEFAULT *problem.GetProblemListResponse

func (p *GetProblemListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetProblemListResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetProblemListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetProblemListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetProblemListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetProblemListResult) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetProblemListResult) GetSuccess() *problem.GetProblemListResponse {
	if !p.IsSetSuccess() {
		return GetProblemListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetProblemListResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetProblemListResponse)
}

func (p *GetProblemListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetProblemListResult) GetResult() interface{} {
	return p.Success
}

func getProblemCountHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetProblemCountRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetProblemCount(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetProblemCountArgs:
		success, err := handler.(problem.ProblemService).GetProblemCount(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetProblemCountResult)
		realResult.Success = success
	}
	return nil
}
func newGetProblemCountArgs() interface{} {
	return &GetProblemCountArgs{}
}

func newGetProblemCountResult() interface{} {
	return &GetProblemCountResult{}
}

type GetProblemCountArgs struct {
	Req *problem.GetProblemCountRequest
}

func (p *GetProblemCountArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetProblemCountRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetProblemCountArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetProblemCountArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetProblemCountArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetProblemCountArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemCountRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetProblemCountArgs_Req_DEFAULT *problem.GetProblemCountRequest

func (p *GetProblemCountArgs) GetReq() *problem.GetProblemCountRequest {
	if !p.IsSetReq() {
		return GetProblemCountArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetProblemCountArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetProblemCountArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetProblemCountResult struct {
	Success *problem.GetProblemCountResponse
}

var GetProblemCountResult_Success_DEFAULT *problem.GetProblemCountResponse

func (p *GetProblemCountResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetProblemCountResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetProblemCountResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetProblemCountResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetProblemCountResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetProblemCountResult) Unmarshal(in []byte) error {
	msg := new(problem.GetProblemCountResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetProblemCountResult) GetSuccess() *problem.GetProblemCountResponse {
	if !p.IsSetSuccess() {
		return GetProblemCountResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetProblemCountResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetProblemCountResponse)
}

func (p *GetProblemCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetProblemCountResult) GetResult() interface{} {
	return p.Success
}

func getContestProblemHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetContestProblemRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetContestProblem(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetContestProblemArgs:
		success, err := handler.(problem.ProblemService).GetContestProblem(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetContestProblemResult)
		realResult.Success = success
	}
	return nil
}
func newGetContestProblemArgs() interface{} {
	return &GetContestProblemArgs{}
}

func newGetContestProblemResult() interface{} {
	return &GetContestProblemResult{}
}

type GetContestProblemArgs struct {
	Req *problem.GetContestProblemRequest
}

func (p *GetContestProblemArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetContestProblemRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetContestProblemArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetContestProblemArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetContestProblemArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetContestProblemArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetContestProblemRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetContestProblemArgs_Req_DEFAULT *problem.GetContestProblemRequest

func (p *GetContestProblemArgs) GetReq() *problem.GetContestProblemRequest {
	if !p.IsSetReq() {
		return GetContestProblemArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetContestProblemArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetContestProblemArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetContestProblemResult struct {
	Success *problem.GetContestProblemResponse
}

var GetContestProblemResult_Success_DEFAULT *problem.GetContestProblemResponse

func (p *GetContestProblemResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetContestProblemResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetContestProblemResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetContestProblemResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetContestProblemResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetContestProblemResult) Unmarshal(in []byte) error {
	msg := new(problem.GetContestProblemResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetContestProblemResult) GetSuccess() *problem.GetContestProblemResponse {
	if !p.IsSetSuccess() {
		return GetContestProblemResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetContestProblemResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetContestProblemResponse)
}

func (p *GetContestProblemResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetContestProblemResult) GetResult() interface{} {
	return p.Success
}

func getContestProblemListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetContestProblemListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetContestProblemList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetContestProblemListArgs:
		success, err := handler.(problem.ProblemService).GetContestProblemList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetContestProblemListResult)
		realResult.Success = success
	}
	return nil
}
func newGetContestProblemListArgs() interface{} {
	return &GetContestProblemListArgs{}
}

func newGetContestProblemListResult() interface{} {
	return &GetContestProblemListResult{}
}

type GetContestProblemListArgs struct {
	Req *problem.GetContestProblemListRequest
}

func (p *GetContestProblemListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetContestProblemListRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetContestProblemListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetContestProblemListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetContestProblemListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetContestProblemListArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetContestProblemListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetContestProblemListArgs_Req_DEFAULT *problem.GetContestProblemListRequest

func (p *GetContestProblemListArgs) GetReq() *problem.GetContestProblemListRequest {
	if !p.IsSetReq() {
		return GetContestProblemListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetContestProblemListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetContestProblemListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetContestProblemListResult struct {
	Success *problem.GetContestProblemListResponse
}

var GetContestProblemListResult_Success_DEFAULT *problem.GetContestProblemListResponse

func (p *GetContestProblemListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetContestProblemListResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetContestProblemListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetContestProblemListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetContestProblemListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetContestProblemListResult) Unmarshal(in []byte) error {
	msg := new(problem.GetContestProblemListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetContestProblemListResult) GetSuccess() *problem.GetContestProblemListResponse {
	if !p.IsSetSuccess() {
		return GetContestProblemListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetContestProblemListResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetContestProblemListResponse)
}

func (p *GetContestProblemListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetContestProblemListResult) GetResult() interface{} {
	return p.Success
}

func createProblemHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.CreateProblemRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).CreateProblem(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateProblemArgs:
		success, err := handler.(problem.ProblemService).CreateProblem(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateProblemResult)
		realResult.Success = success
	}
	return nil
}
func newCreateProblemArgs() interface{} {
	return &CreateProblemArgs{}
}

func newCreateProblemResult() interface{} {
	return &CreateProblemResult{}
}

type CreateProblemArgs struct {
	Req *problem.CreateProblemRequest
}

func (p *CreateProblemArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.CreateProblemRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateProblemArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateProblemArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateProblemArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateProblemArgs) Unmarshal(in []byte) error {
	msg := new(problem.CreateProblemRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateProblemArgs_Req_DEFAULT *problem.CreateProblemRequest

func (p *CreateProblemArgs) GetReq() *problem.CreateProblemRequest {
	if !p.IsSetReq() {
		return CreateProblemArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateProblemArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateProblemArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateProblemResult struct {
	Success *problem.CreateProblemResponse
}

var CreateProblemResult_Success_DEFAULT *problem.CreateProblemResponse

func (p *CreateProblemResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.CreateProblemResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateProblemResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateProblemResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateProblemResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateProblemResult) Unmarshal(in []byte) error {
	msg := new(problem.CreateProblemResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateProblemResult) GetSuccess() *problem.CreateProblemResponse {
	if !p.IsSetSuccess() {
		return CreateProblemResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateProblemResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.CreateProblemResponse)
}

func (p *CreateProblemResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateProblemResult) GetResult() interface{} {
	return p.Success
}

func deleteProblemHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.DeleteProblemRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).DeleteProblem(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteProblemArgs:
		success, err := handler.(problem.ProblemService).DeleteProblem(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteProblemResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteProblemArgs() interface{} {
	return &DeleteProblemArgs{}
}

func newDeleteProblemResult() interface{} {
	return &DeleteProblemResult{}
}

type DeleteProblemArgs struct {
	Req *problem.DeleteProblemRequest
}

func (p *DeleteProblemArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.DeleteProblemRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteProblemArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteProblemArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteProblemArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteProblemArgs) Unmarshal(in []byte) error {
	msg := new(problem.DeleteProblemRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteProblemArgs_Req_DEFAULT *problem.DeleteProblemRequest

func (p *DeleteProblemArgs) GetReq() *problem.DeleteProblemRequest {
	if !p.IsSetReq() {
		return DeleteProblemArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteProblemArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteProblemArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteProblemResult struct {
	Success *problem.DeleteProblemResponse
}

var DeleteProblemResult_Success_DEFAULT *problem.DeleteProblemResponse

func (p *DeleteProblemResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.DeleteProblemResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteProblemResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteProblemResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteProblemResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteProblemResult) Unmarshal(in []byte) error {
	msg := new(problem.DeleteProblemResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteProblemResult) GetSuccess() *problem.DeleteProblemResponse {
	if !p.IsSetSuccess() {
		return DeleteProblemResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteProblemResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.DeleteProblemResponse)
}

func (p *DeleteProblemResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteProblemResult) GetResult() interface{} {
	return p.Success
}

func updateProblemHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.UpdateProblemRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).UpdateProblem(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateProblemArgs:
		success, err := handler.(problem.ProblemService).UpdateProblem(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateProblemResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateProblemArgs() interface{} {
	return &UpdateProblemArgs{}
}

func newUpdateProblemResult() interface{} {
	return &UpdateProblemResult{}
}

type UpdateProblemArgs struct {
	Req *problem.UpdateProblemRequest
}

func (p *UpdateProblemArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.UpdateProblemRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *UpdateProblemArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *UpdateProblemArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *UpdateProblemArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateProblemArgs) Unmarshal(in []byte) error {
	msg := new(problem.UpdateProblemRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateProblemArgs_Req_DEFAULT *problem.UpdateProblemRequest

func (p *UpdateProblemArgs) GetReq() *problem.UpdateProblemRequest {
	if !p.IsSetReq() {
		return UpdateProblemArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateProblemArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateProblemArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateProblemResult struct {
	Success *problem.UpdateProblemResponse
}

var UpdateProblemResult_Success_DEFAULT *problem.UpdateProblemResponse

func (p *UpdateProblemResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.UpdateProblemResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *UpdateProblemResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *UpdateProblemResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *UpdateProblemResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateProblemResult) Unmarshal(in []byte) error {
	msg := new(problem.UpdateProblemResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateProblemResult) GetSuccess() *problem.UpdateProblemResponse {
	if !p.IsSetSuccess() {
		return UpdateProblemResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateProblemResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.UpdateProblemResponse)
}

func (p *UpdateProblemResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateProblemResult) GetResult() interface{} {
	return p.Success
}

func createTestcaseHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.CreateTestcaseRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).CreateTestcase(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateTestcaseArgs:
		success, err := handler.(problem.ProblemService).CreateTestcase(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateTestcaseResult)
		realResult.Success = success
	}
	return nil
}
func newCreateTestcaseArgs() interface{} {
	return &CreateTestcaseArgs{}
}

func newCreateTestcaseResult() interface{} {
	return &CreateTestcaseResult{}
}

type CreateTestcaseArgs struct {
	Req *problem.CreateTestcaseRequest
}

func (p *CreateTestcaseArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.CreateTestcaseRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CreateTestcaseArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CreateTestcaseArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CreateTestcaseArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateTestcaseArgs) Unmarshal(in []byte) error {
	msg := new(problem.CreateTestcaseRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateTestcaseArgs_Req_DEFAULT *problem.CreateTestcaseRequest

func (p *CreateTestcaseArgs) GetReq() *problem.CreateTestcaseRequest {
	if !p.IsSetReq() {
		return CreateTestcaseArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateTestcaseArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateTestcaseArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateTestcaseResult struct {
	Success *problem.CreateTestcaseResponse
}

var CreateTestcaseResult_Success_DEFAULT *problem.CreateTestcaseResponse

func (p *CreateTestcaseResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.CreateTestcaseResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CreateTestcaseResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CreateTestcaseResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CreateTestcaseResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateTestcaseResult) Unmarshal(in []byte) error {
	msg := new(problem.CreateTestcaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateTestcaseResult) GetSuccess() *problem.CreateTestcaseResponse {
	if !p.IsSetSuccess() {
		return CreateTestcaseResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateTestcaseResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.CreateTestcaseResponse)
}

func (p *CreateTestcaseResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateTestcaseResult) GetResult() interface{} {
	return p.Success
}

func getTestcaseHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.GetTestcaseRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).GetTestcase(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetTestcaseArgs:
		success, err := handler.(problem.ProblemService).GetTestcase(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetTestcaseResult)
		realResult.Success = success
	}
	return nil
}
func newGetTestcaseArgs() interface{} {
	return &GetTestcaseArgs{}
}

func newGetTestcaseResult() interface{} {
	return &GetTestcaseResult{}
}

type GetTestcaseArgs struct {
	Req *problem.GetTestcaseRequest
}

func (p *GetTestcaseArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.GetTestcaseRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *GetTestcaseArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *GetTestcaseArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *GetTestcaseArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetTestcaseArgs) Unmarshal(in []byte) error {
	msg := new(problem.GetTestcaseRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetTestcaseArgs_Req_DEFAULT *problem.GetTestcaseRequest

func (p *GetTestcaseArgs) GetReq() *problem.GetTestcaseRequest {
	if !p.IsSetReq() {
		return GetTestcaseArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetTestcaseArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTestcaseArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetTestcaseResult struct {
	Success *problem.GetTestcaseResponse
}

var GetTestcaseResult_Success_DEFAULT *problem.GetTestcaseResponse

func (p *GetTestcaseResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.GetTestcaseResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *GetTestcaseResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *GetTestcaseResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *GetTestcaseResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetTestcaseResult) Unmarshal(in []byte) error {
	msg := new(problem.GetTestcaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetTestcaseResult) GetSuccess() *problem.GetTestcaseResponse {
	if !p.IsSetSuccess() {
		return GetTestcaseResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetTestcaseResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.GetTestcaseResponse)
}

func (p *GetTestcaseResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTestcaseResult) GetResult() interface{} {
	return p.Success
}

func deleteTestcaseHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(problem.DeleteTestcaseRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(problem.ProblemService).DeleteTestcase(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteTestcaseArgs:
		success, err := handler.(problem.ProblemService).DeleteTestcase(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteTestcaseResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteTestcaseArgs() interface{} {
	return &DeleteTestcaseArgs{}
}

func newDeleteTestcaseResult() interface{} {
	return &DeleteTestcaseResult{}
}

type DeleteTestcaseArgs struct {
	Req *problem.DeleteTestcaseRequest
}

func (p *DeleteTestcaseArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(problem.DeleteTestcaseRequest)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *DeleteTestcaseArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *DeleteTestcaseArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *DeleteTestcaseArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteTestcaseArgs) Unmarshal(in []byte) error {
	msg := new(problem.DeleteTestcaseRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteTestcaseArgs_Req_DEFAULT *problem.DeleteTestcaseRequest

func (p *DeleteTestcaseArgs) GetReq() *problem.DeleteTestcaseRequest {
	if !p.IsSetReq() {
		return DeleteTestcaseArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteTestcaseArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteTestcaseArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteTestcaseResult struct {
	Success *problem.DeleteTestcaseResponse
}

var DeleteTestcaseResult_Success_DEFAULT *problem.DeleteTestcaseResponse

func (p *DeleteTestcaseResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(problem.DeleteTestcaseResponse)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *DeleteTestcaseResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *DeleteTestcaseResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *DeleteTestcaseResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteTestcaseResult) Unmarshal(in []byte) error {
	msg := new(problem.DeleteTestcaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteTestcaseResult) GetSuccess() *problem.DeleteTestcaseResponse {
	if !p.IsSetSuccess() {
		return DeleteTestcaseResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteTestcaseResult) SetSuccess(x interface{}) {
	p.Success = x.(*problem.DeleteTestcaseResponse)
}

func (p *DeleteTestcaseResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteTestcaseResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) GetProblem(ctx context.Context, Req *problem.GetProblemRequest) (r *problem.GetProblemResponse, err error) {
	var _args GetProblemArgs
	_args.Req = Req
	var _result GetProblemResult
	if err = p.c.Call(ctx, "GetProblem", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetProblemList(ctx context.Context, Req *problem.GetProblemListRequest) (r *problem.GetProblemListResponse, err error) {
	var _args GetProblemListArgs
	_args.Req = Req
	var _result GetProblemListResult
	if err = p.c.Call(ctx, "GetProblemList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetProblemCount(ctx context.Context, Req *problem.GetProblemCountRequest) (r *problem.GetProblemCountResponse, err error) {
	var _args GetProblemCountArgs
	_args.Req = Req
	var _result GetProblemCountResult
	if err = p.c.Call(ctx, "GetProblemCount", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetContestProblem(ctx context.Context, Req *problem.GetContestProblemRequest) (r *problem.GetContestProblemResponse, err error) {
	var _args GetContestProblemArgs
	_args.Req = Req
	var _result GetContestProblemResult
	if err = p.c.Call(ctx, "GetContestProblem", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetContestProblemList(ctx context.Context, Req *problem.GetContestProblemListRequest) (r *problem.GetContestProblemListResponse, err error) {
	var _args GetContestProblemListArgs
	_args.Req = Req
	var _result GetContestProblemListResult
	if err = p.c.Call(ctx, "GetContestProblemList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateProblem(ctx context.Context, Req *problem.CreateProblemRequest) (r *problem.CreateProblemResponse, err error) {
	var _args CreateProblemArgs
	_args.Req = Req
	var _result CreateProblemResult
	if err = p.c.Call(ctx, "CreateProblem", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteProblem(ctx context.Context, Req *problem.DeleteProblemRequest) (r *problem.DeleteProblemResponse, err error) {
	var _args DeleteProblemArgs
	_args.Req = Req
	var _result DeleteProblemResult
	if err = p.c.Call(ctx, "DeleteProblem", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateProblem(ctx context.Context, Req *problem.UpdateProblemRequest) (r *problem.UpdateProblemResponse, err error) {
	var _args UpdateProblemArgs
	_args.Req = Req
	var _result UpdateProblemResult
	if err = p.c.Call(ctx, "UpdateProblem", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateTestcase(ctx context.Context, Req *problem.CreateTestcaseRequest) (r *problem.CreateTestcaseResponse, err error) {
	var _args CreateTestcaseArgs
	_args.Req = Req
	var _result CreateTestcaseResult
	if err = p.c.Call(ctx, "CreateTestcase", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetTestcase(ctx context.Context, Req *problem.GetTestcaseRequest) (r *problem.GetTestcaseResponse, err error) {
	var _args GetTestcaseArgs
	_args.Req = Req
	var _result GetTestcaseResult
	if err = p.c.Call(ctx, "GetTestcase", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteTestcase(ctx context.Context, Req *problem.DeleteTestcaseRequest) (r *problem.DeleteTestcaseResponse, err error) {
	var _args DeleteTestcaseArgs
	_args.Req = Req
	var _result DeleteTestcaseResult
	if err = p.c.Call(ctx, "DeleteTestcase", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
